# jonashaslbeck@gmail.com; dablander.fabian@gmail.com; January, 14th, 2019


# -----------------------------------------------------------------------------
# ---------- Load Packages & Auxilliary Functions  ----------------------------
# -----------------------------------------------------------------------------

# Packages
library(shape)
library(scales)
library(weights)
library(latex2exp)
library(RColorBrewer)
library(plotfunctions)
# Load Aux Functions
source("aux_functions.R")

# -----------------------------------------------------------------------------
# ---------- Preprocess Simulation Results  -----------------------------------
# -----------------------------------------------------------------------------


#' Load the 60 x 100 VAR matrices
#' @param file (string) file to the 60 x 100 VAR matrices
#' @returns all_matrices (matrix)
get_60_1000_matrices <- function(file = "files/Models_60cells.RDS") {
  l_CM <- readRDS(file = "files/Models_60cells.RDS")
  
  all_matrices <- vector('list', length = 6000)
  
  ix <- 1
  for (i in seq(60)) {
    for (j in seq(100)) {
      all_matrices[[ix]] <- l_CM[[i]][[j]]
      ix <- ix + 1
    }
  }
  
  all_matrices
}


#' Aggregregate 100 Simulation output files in 1 object
#' @param path (string) path to the 100 files from LISA (supercomputer)
#' @returns out_var (list)
get_aggregate_file <- function(path = 'output/') {
  models <- list()
  
  i <- 1
  for (file in list.files(path)) {
    m <- readRDS(paste0(path, '/', file))
    models[[i]] <- prune_simoutput(m)
    rm(m)
    i <- i + 1
  }
  
  out_var <- vector('list', length = 60)
  
  for (i in seq(60)) {
    out_var[[i]] <- vector('list', length = 100)
  }
  
  
  for (i in seq(60)) {
    for (j in seq(100)) {
      out_var[[i]][[j]] <- models[[j]][[i]]
    }
  }
  
  out_var
}

PATH_TO_OUTVAR = NULL
PATH_TO_OUTVAR = '~/Desktop/ARVAR/out_VAR_500.RDS'

if (is.null(PATH_TO_OUTVAR)) {
  out_var <- get_aggregate_file()
  # saveRDS(out_var, "files/out_var.RDS") # uncomment if you want to save them locally
} else {
  out_var <- readRDS(PATH_TO_OUTVAR)
}



# --------------------------------------------
# -------- Compute Frequency of Cells --------
# --------------------------------------------

# Characteristics of all 9998 stable VAR matrices of initial 10000
out_stable <- readRDS("files/initial10000.RDS")
m_cell_fill <- readRDS("files/cell_positions.RDS")

# Function to compute cell frq
get_cell <- function(row, p = 6) {
  is_within <- function(x, vec) x > vec[1] && x < vec[2]
  
  R <- row[1]
  D <- row[2]
  
  cell_pos <- apply(m_cell_fill, 1, function(x) { 
    cell <- as.numeric(x)
    Rbounds <- c(cell[1] - .25, cell[1] + .25)
    Dbounds <- c(cell[2] - .025, cell[2] + .025)
    is_within(D, Dbounds) && is_within(R, Rbounds)
  })
  
  which(cell_pos)
}

out_A <- apply(out_stable, 1, get_cell)
cell_weights <- table(out_A) / length(out_A) # 60 cell weights
model_weights <- get_model_weights()
model_weights_all <- rep(model_weights, each = 100)
model_weights_all <- model_weights_all / sum(model_weights_all)


# -----------------------------------------------------------------------------
# ---------- Global Variable Definitions  -------------------------------------
# -----------------------------------------------------------------------------

n_rep <- 100
n_cells <- 60
n_seq <- 8:500
n_len <- n_nvar <- length(n_seq)


# -----------------------------------------------------------------------------
# ---------- Figure 1: Preparation & Plotting ---------------------------------
# -----------------------------------------------------------------------------
# Here we need to prepare the data structures required for the first plot, panels (a), (b), and (c)

# compute n_switch, i.e., when estimation error of VAR is lower than estimation error of AR
diffs6000 <- lapply(seq(n_cells), function(cell) {
  
  ee_ar <- lapply(out_var[[cell]], function(x) x$EE[, 1])
  ee_var <- lapply(out_var[[cell]], function(x) x$EE[, 2])
  
  ee_ar <- do.call(rbind, ee_ar)
  ee_var <- do.call(rbind, ee_var)
  
  ee_ar - ee_var
})

# get 6000 model medians across 100 iterations
diffs_mat6000 <- do.call('rbind', diffs6000)



# PATH_TO_DIFFSMAT <- NULL
PATH_TO_DIFFSMAT <- '~/Desktop/ARVAR/diffs_mat.RDS'

if (is.null(PATH_TO_DIFFSMAT)) {
  diffs_mat <- get_all_ee_curves(out_var, cells = seq(60), cols = seq(length(n_seq)))
  # saveRDS(diffs_mat, 'files/diffs_mat.RDS') # uncomment to save diffs_mat locally
} else {
  diffs_mat <- readRDS(PATH_TO_DIFFSMAT)
}

# get 6000 models with 100 iterations (as a list)
diffs6000_100 <- list()

for (i in seq(0, 5999)) { # we have 6000 models and 100 iterations
  lo <- ifelse(i == 0, 1, i*100)
  hi <- (i + 1)*100
  diffs6000_100[[i+1]] <- diffs_mat[seq(lo, hi), ]
}


#' Plotting function for Figure 1
plot_fig123 <- function(
  diffs_mat, model_weights = NULL, figtype = 1, n_cells = 60, n_seq = 25:200,
  ylim = c(-.052, .052), main = '', letter = '',
  ylab = TeX('$$EE_{AR} - EE_{VAR}$$'), xlab = "Number of observations n", seed = 1
  ) {
  
  if (figtype == 1) {
    # resample 600.000 according to their probabilities
    diffs_mat <- get_weighted_samples(diffs_mat, model_weights, seed = seed)
  }
  
  skip <- seq(25 - 8)
  
  plot.new()
  xlim <- c(n_seq[1], n_seq[length(n_seq)])
  xlim <- c(25, 200)
   
  plot.window(
    xlim = xlim, ylim = ylim, yaxs = 'i'
  )
  x_labels <- scales::pretty_breaks(n = 10)(xlim)
  x_labels <- round(seq(25, 200, 25))
  title(main = main)
  title(xlab = xlab, cex.lab = 1.2)
  title(ylab = ylab, line = 1.8, cex.lab = 1.2)
  
  plot_line <- function(x, y, lo, hi, col, col_shade = 'grey',...) {
    lines(x, y, panel.first = polygon(
      c(n_seq, rev(n_seq)),
      c(lo, rev(hi)),
      col = grDevices::adjustcolor(col_shade, alpha = .4), border = NA
      ), col = col, ...
    )
  }
    
  if (figtype == 1) {
    diffs_mean <- apply(diffs_mat, 2, median)[-skip]
    diffs_sd <- apply(diffs_mat, 2, sd)[-skip]
    
    plot_line(n_seq, diffs_mean, diffs_mean - diffs_sd, diffs_mean + diffs_sd, col = 'black')
  }
  
  if (!is.null(model_weights)) {
    alpha <- (model_weights) / max(20*model_weights)
  } else {
    alpha <- rep(.9, n_cells)
  }
  
  colours <- rep('grey', 6000)
  colours[c(7, 23, 35)] <- brewer.pal(3, 'Set1') # red, blue, green
  cells <- which(colours != 'grey')
  
  
  if (figtype == 2) {
    
    for (cell in seq(length(model_weights))) {
      ee_curve <- diffs_mat[cell, ][-skip]
      
      col <- colours[cell]
      colour <- ifelse(col == 'grey', adjustcolor(col, alpha = alpha[cell]), col)
      plot_line(n_seq, ee_curve, ee_curve, ee_curve, col = colour)
    }
    
    for (cell in cells) {
      ee_curve <- diffs_mat[cell, ][-skip]
      
      colour <- colours[cell]
      plot_line(n_seq, ee_curve, ee_curve, ee_curve, col = colour)
    }
  }
  
  if (figtype == 3) {
    for (cell in cells) {
      cell_models <- diffs_mat[[cell]]
      mean_cell <- apply(cell_models, 2, median)[-skip]
      sd_cell <- apply(cell_models, 2, sd)[-skip]
      
      col <- colours[cell]
      plot_line(n_seq, mean_cell, mean_cell - sd_cell, mean_cell + sd_cell, col = col, col_shade = col)
    }
  }
  
  # plot axes the last
  # axis(1, c(xlim[1], 50, 100, 150, 200))
  axis(1, x_labels, cex.axis = 1.2)
  axis(2, at = c(-.05, 0, .05), labels = c('', '0', ''), las = 2, cex.axis = 1.2)
  
  lines(c(0, 200), c(0, 0), lty = 2, col = 'grey')
  text(25, 0.048, letter, col = 'black', cex = 1.5, adj = 0)
  
  # draw VAR is better with arrows
  Arrows(x0 = 199, y0 = .017, x1 = 199, y1 = .003, arr.type = 'triangle', arr.length = .2, arr.width = .2)
  text(199, .018, "VAR better", col = 'black', cex = 1, adj = 0, srt = 90)
  Arrows(x0 = 199, y0 = .039, x1 = 199, y1 = .049, arr.type = 'triangle', arr.length = .2, arr.width = .2)
  
  # draw VAR is better with arrows
  Arrows(x0 = 199, y0 = -.015, x1 = 199, y1 = -.003, arr.type = 'triangle', arr.length = .2, arr.width = .2)
  text(199, -.034, "AR better", col = 'black', cex = 1, adj = 0, srt = 90)
  Arrows(x0 = 199, y0 = -.035, x1 = 199, y1 = -.049, arr.type = 'triangle', arr.length = .2, arr.width = .2)
}

# plot_fig123(diffs6000_100, model_weights, figtype = 3, letter = '(c)')

n_show <- seq(193) # don't show the first 8

par(pty = 'm', mfrow = c(1, 1))
pdf('figures/Fig1-a.pdf', width = 6, height = 6)
plot_fig123(diffs_mat[, n_show], model_weights_all, figtype = 1, letter = '(a)')
dev.off()

pdf('figures/Fig1-b.pdf', width = 6, height = 6)
plot_fig123(diffs_mat6000[, n_show], model_weights, figtype = 2, letter = '(b)')
dev.off()

pdf('figures/Fig1-c.pdf', width = 6, height = 6)
plot_fig123(lapply(diffs6000_100, function(x) x[, n_show]), model_weights, figtype = 3, letter = '(c)')
dev.off()


#' Computes the n at which the estimation error is better for VAR
#' either using resampling or not
compute_nswitch <- function(diffs_mat, model_weights = NULL, seed = 1) {
  if (!is.null(model_weights)) {
    diffs_mat <- get_weighted_samples(diffs_mat, model_weights, seed = seed)
  }
  
  nswitch <- apply(diffs_mat, 1, function(diffs) which(diffs > 0)[1])
  nswitch
}

# weighted nswitch for all 600.000 runs
nswitch_all <- compute_nswitch(diffs_mat, model_weights_all, seed = 1)
nswitch_all[is.na(nswitch_all)] <- max(n_seq) # 327 cases!

# compute median nswitch across cells; here we don't need to resample!
nswitch_cells <- sapply(seq(n_cells), function(cell) {
  nswitch <- apply(diffs6000[[cell]], 1, function(x) which(x > 0)[1])
  nswitch[is.na(nswitch)] <- max(n_seq)
  median(nswitch)
})



# -----------------------------------------------------------------------------
# ---------- Figure 2: plot_gaps and plot_histogram (estimation error) --------
# -----------------------------------------------------------------------------

#' Plot the n at which the estimation error crosses (median across 100 models) for each cell
#' as a function of R and D
plot_gaps <- function(m_gap, main, m_cell_fill, cols = brewer.pal(11, "PiYG"), cex = 1, alpha = 1) {
  
  # Set up Plot
  plot.new()
  plot.window(xlim=c(0, 8), ylim=c(0, 0.6))
  axis(1, 0:8)
  axis(2, seq(0, .6, length=7), las=2, cex.axis = 1)
  title(main = main)
  title(xlab = "Ratio: Diagonal/Off-Diagonal", cex.lab = 1)
  title(ylab = "Dimensionality", cex.lab = 1)
  
  # Plot the cells
  m_gap_cols<-m_gap+abs(min(m_gap))
  ind_color <-round((m_gap_cols/max(m_gap_cols))*9)+1
  col_gap <- cols[ind_color]
  
  hs_y <- .025
  hs_x <- .25
  
  for(k in 1:60) rect(xleft = m_cell_fill[k, 1] - hs_x, 
                      ybottom = m_cell_fill[k, 2] - hs_y,  
                      xright = m_cell_fill[k, 1] + hs_x, 
                      ytop = m_cell_fill[k, 2] + hs_y, 
                      col = grDevices::adjustcolor(col_gap[k], alpha = alpha))
  
  
  # Plot the Gap
  text(m_cell_fill[, 1], m_cell_fill[, 2], round(m_gap), cex = cex)
}


#' Plot the sampling distribution of the ns at which the estimation error difference crosses
#' (i.e., VAR outperforms AR); uses all 600.000 models
plot_histogram <- function(nswitch, med, xlim) {
  
  hist(
    nswitch, breaks = 50, main = '',
    xlab = TeX('$$n_{e}$$'), col = 'grey76', ylab = '',
    xlim = xlim, xaxt = 'n', las = 2, yaxt = 'n', ylim = c(0, 70000)
  )
  # x_labels <- scales::pretty_breaks(n = 8)(xlim)
  x_labels <- c(8, seq(40, 500, 40))
  x_labels <- c(8, 50, 100, 150, 200, 250, 300, 350, 400, 450, 500)
  axis(1, x_labels, las = 1)
  axis(2, labels = FALSE)
  title(ylab = 'Frequency', line = 1.8)
  
  lines(c(med, med), c(0, 55000), lty = 2, lwd = 1.2)
}


cols <- brewer.pal(9, 'Blues')
more_cols <- colorRampPalette(cols)(14)

pdf('figures/Fig2-EE-Gap-Hist.pdf', width = 10, height = 5)
par(mfrow = c(1, 2), pty = 's')
plot_gaps(nswitch_cells, '', m_cell_fill, cols = more_cols, cex = .5, alpha = 1)
.gradientLegend(
  valRange = round(c(min(nswitch_cells), max(nswitch_cells))),
  color = more_cols, n.seg = 2, pos = c(7, .1, 7.5, .2), coords = TRUE, cex = 0.5
)
text(7.5, 0.60, '(a)', col = 'black', cex = 1.2, adj = 0)
plot_histogram(nswitch_all, med = median(nswitch_all), xlim = c(8, 493))
text(470, 69400, '(b)', col = 'black', cex = 1.2, adj = 0)
dev.off()


# -----------------------------------------------------------------------------
# ---------- Figure 3: Plot estimation and prediction error curves across N ---
# -----------------------------------------------------------------------------

# get 6000 models with 100 iterations (as a list), PE and EE
models6000_100 <- list()

j <- 1
for (cell in seq(n_cells)) {
  for (iter in seq(100)) {
    models6000_100[[j]] <- out_var[[cell]][[iter]]
    j <- j + 1
  }
}

#' Given a model, plot the estimation and prediction error curves for AR and VAR
plot_model_curves <- function(models6000_100, model, ylim, lwd, legend.cex = .5,
                              legend, n_seq_ss, block_cols = c("darkgreen", "tomato"),
                              alpha_val = .2, n_seq = 8:500) {
  
  # ID subsequence
  ind_ss <- n_seq %in% n_seq_ss
  
  # Set up Plot
  plot.new()
  plot.window(xlim = range(n_seq[ind_ss]), ylim=ylim)
  
  rescale_errors <- function(ar, var) {
    ar_err <- matrix(NA, nrow = nrow(ar), ncol = ncol(ar))
    var_err <- matrix(NA, nrow = nrow(ar), ncol = ncol(ar))
    
    for (i in seq(nrow(ar))) {
      mmin <- min(c(ar[i, ], var[i, ]))
      mmax <- max(c(ar[i, ], var[i, ]))
      
      ar_err[i, ] <- (ar[i, ] - mmin) / mmax
      var_err[i, ] <- (var[i, ] - mmin) / mmax
    }
    
    list('ar' = ar_err, 'var' = var_err)
  }
  
  m <- models6000_100[[model]]
  
  ee_ar <- t(m$EE_all[, 1, ])
  ee_var <- t(m$EE_all[, 2, ])
  pe_ar <- t(m$PE_all[, 1, ])
  pe_var <- t(m$PE_all[, 2, ])
  
  ee <- rescale_errors(ee_ar, ee_var)
  ee$ar <- list(
    'mean' = apply(ee$ar, 2, mean),
    'sd' = apply(ee$ar, 2, sd),
    'lo' = apply(ee$ar, 2, quantile, .25),
    'hi' = apply(ee$ar, 2, quantile, .75)
  )
  
  ee$var <- list(
    'mean' = apply(ee$var, 2, mean),
    'sd' = apply(ee$var, 2, sd),
    'lo' = apply(ee$var, 2, quantile, .25),
    'hi' = apply(ee$var, 2, quantile, .75)
  )
  
  pe <- rescale_errors(pe_ar, pe_var)
  pe$ar <- list(
    'mean' = apply(pe$ar, 2, mean),
    'sd' = apply(pe$ar, 2, sd),
    'lo' = apply(pe$ar, 2, quantile, .25),
    'hi' = apply(pe$ar, 2, quantile, .75)
  )
  
  pe$var <- list(
    'mean' = apply(pe$var, 2, mean),
    'sd' = apply(pe$var, 2, sd),
    'lo' = apply(pe$var, 2, quantile, .25),
    'hi' = apply(pe$var, 2, quantile, .75)
  )
  
  # PE AR
  lines(
    n_seq[ind_ss], pe$ar$mean[ind_ss], type="l", lty = 3, lwd=lwd,
    panel.first =  polygon(
      c(n_seq[ind_ss], rev(n_seq[ind_ss])),
      c(pe$ar$lo[ind_ss], rev(pe$ar$hi[ind_ss])),
      col = grDevices::adjustcolor('gainsboro', alpha = .4), border = NA
    )
  )
  
  # PE VAR
  lines(
    n_seq[ind_ss], pe$var$mean[ind_ss], type="l", lty = 3, lwd=lwd, col = 'red',
    panel.first =  polygon(
      c(n_seq[ind_ss], rev(n_seq[ind_ss])),
      c(pe$var$lo[ind_ss], rev(pe$var$hi[ind_ss])),
      col = grDevices::adjustcolor('gainsboro', alpha = .4), border = NA
    )
  )
  
  # EE AR
  lines(
    n_seq[ind_ss], ee$ar$mean[ind_ss], type="l", lty = 1, lwd=lwd,
    panel.first = polygon(
      c(n_seq[ind_ss], rev(n_seq[ind_ss])),
      c(ee$ar$lo[ind_ss], rev(ee$ar$hi[ind_ss])),
      col = grDevices::adjustcolor('gainsboro', alpha = .4), border = NA
    )
  )
  
  # EE VAR
  lines(
    n_seq[ind_ss], ee$var$mean[ind_ss], type="l", lty = 1, lwd=lwd, col = 'red',
    panel.first = polygon(
      c(n_seq[ind_ss], rev(n_seq[ind_ss])),
      c(ee$var$lo[ind_ss], rev(ee$var$hi[ind_ss])),
      col = grDevices::adjustcolor('gainsboro', alpha = .4), border = NA
    )
  )
  
  n_var <- 193
  # Plot Box
  ## Plot Gap
  # Intersection point PE
  signs_y <- pe$ar$mean - pe$var$mean
  int_n <- sign(signs_y[-1]) == sign(signs_y[-n_var]) 
  n_PE <- n_seq[which(int_n == FALSE)+1] # first n variation after the switch
  
  # Intersection point EE
  signs_y <- ee$ar$mean - ee$var$mean
  int_n <- sign(signs_y[-1]) == sign(signs_y[-n_var]) 
  n_EE <- n_seq[which(int_n == FALSE)+1] # first n variation after the switch
  
  n_ax_cmb <- c(n_PE, n_EE)
  
  ifelse(n_EE > n_PE, col <- block_cols[1], col <- block_cols[2])
  col <- scales::alpha(col, alpha = alpha_val)
  
  rect(
    xleft = min(n_ax_cmb), ybottom = 0, xright = max(n_ax_cmb),
    ytop = .25, col = col, border = FALSE
  )
  
  if (legend) {
    legend("topright", 
           legend = c("Estimation Error AR", "Estimation Error VAR",
                      "Prediction Error AR", "Prediction Error VAR"), 
           lty=c(1,1,3,3), 
           col=c("black", "red", "black", "red"), 
           bty = "n", 
           lwd = rep(lwd, 4), 
           cex = legend.cex)
  }
  
  x_labels <- c(min(n_seq[ind_ss]), median(n_seq[ind_ss]), max(n_seq[ind_ss]))
  y_at <- seq(ylim[1], ylim[2], length.out = 6)
  axis(1, x_labels, las=1)
  axis(2, at = y_at, labels = c('0', '', '', '', '', ''), las = 1)
  
  title(xlab="Number of observations n")
  title(ylab="Scaled MSE", line = 1.8)
  
} # eoF


sc <- 1.2
pdf("figures/Fig-4-ModelGaps.pdf", width = 8*sc, height = 4*sc)

par(mfrow = c(1, 2))
cols <- brewer.pal(11, "PiYG")

plot_model_curves(models6000_100, model = 602, ylim = c(0, .025),lwd = 2, legend = TRUE, 
                  legend.cex = .8, n_seq_ss = 40:160, block_cols = cols[c(9,1)], alpha_val = .2)

plot_model_curves(models6000_100, model = 6000, ylim = c(0, .01), lwd = 2, legend = FALSE, 
                  n_seq_ss = 60:180, block_cols = cols[c(9,1)], alpha_val = .2)

dev.off()



# -----------------------------------------------------------------------------
# ---------- Figure 4: Plot distribution of expected Gap and expectedEE_comp --
# -----------------------------------------------------------------------------

# ------------------------------------------
# -------- Preprocessing panel (a) ---------
# ------------------------------------------
n_rep <- 100
diff_first <- compute_diff_first(out_var)

ngaps_models <- sapply(models6000_100, function(m) {
  ee <- m$EE_all
  pe <- m$PE_all
  gaps <- sapply(seq(100), function(i) {
    ee_diff <- ee[, , i][, 1] - ee[, , i][, 2]
    pe_diff <- pe[, , i][, 1] - pe[, , i][, 2]
    get_gap_diff(pe_diff, ee_diff, n_seq = n_seq)
  })
  
  median(gaps)
})

compute_correlation <- function(models6000_100) {
  ngaps_crossings_models <- lapply(models6000_100, function(m) {
    ee <- m$EE_all
    pe <- m$PE_all
    
    # compute gap and pe crossing
    x <- matrix(NA, nrow = 100, ncol = 2)
    
    for (i in seq(100)) {
      ee_diff <- ee[, , i][, 1] - ee[, , i][, 2]
      pe_diff <- pe[, , i][, 1] - pe[, , i][, 2]
      
      crossing <- which(pe_diff > 0)[1]
      gap <- get_gap_diff(pe_diff, ee_diff, n_seq = n_seq)
      
      x[i, ] <- c(crossing, gap)
    }
    
    apply(x, 2, median)
  })
  
  gaps <- sapply(ngaps_crossings_models, function(x) x[2])
  crossings <- sapply(ngaps_crossings_models, function(x) x[1])
  
  res <- cbind(crossings, gaps)
  na_ix <- unique(c(which(is.na(crossings)), which(is.na(gaps))))
  
  cor(res[-na_ix, ])
}

# correlation between crossing and gap, see paper
# corr <- compute_correlation(models6000_100)


ngaps_models_NArm <- ngaps_models
ngaps_models_NArm <- ngaps_models_NArm[!is.na(ngaps_models_NArm)]


#' Histogram for the expected gap
plot_ngaps_hist <- function(ngaps_models, weight = NULL) {
  xlim <- c(min(ngaps_models) - .5, max(ngaps_models) + 1)
  xlim <- c(-30, 50)
  
  if (!is.null(weight)) {
    wtd.hist(
      ngaps_models, breaks = 100, main = '',
      xlab = TeX('$$Expected n_{gap}$$'), col = 'grey76', ylab = '',
      xlim = xlim, xaxt = 'n', las = 2, weight = weight, ylim = c(0, .3)
    )
    
    title(ylab = 'Weighted Frequency', line = 3)
    
  } else {
    hist(
      ngaps_models, breaks = 50, main = '',
      xlab = TeX('$$Expected n_{gap}$$'), col = 'grey76', ylab = '',
      xlim = xlim, xaxt = 'n', las = 2, weight = weight
    )
    
    title(ylab = 'Frequency', line = 3)
  }
  
  x_labels <- seq(xlim[1], xlim[2], 7)
  x_labels <- seq(-30, 50, 10)
  axis(1, x_labels, las = 1)
  axis(2, labels = FALSE)
  
  med <- median(ngaps_models)
  lines(c(med, med), c(0, 1500), lty = 2, lwd = 1.2)
}


# ------------------------------------------
# -------- Preprocessing panel (b) ---------
# ------------------------------------------


#' Computes EE_comp
get_ee_comp <- function(out_var, n_cells = 60, n_rep = 100, n_nnvar = 100, n_seq = 8:500) {
  a_out <- array(NA, dim = c(n_cells, n_rep, n_nvar, 2)) # 60 cells, 100 models, 100 iterations
  
  for(d in seq(n_cells)) {
    for(i in seq(n_rep)) {
      
      # ----- Compute SE of PEs ------
      SE_PE_VAR <- apply(out_var[[d]][[i]]$PE_all[, 2, ], 1, sd) / sqrt(n_seq)
      
      # ----- Rule 1: -----
      ind_min_PE <- apply(out_var[[d]][[i]]$PE[, 1:2], 1, which.min)
      ind_min_EE <- apply(out_var[[d]][[i]]$EE[, 1:2], 1, which.min)
      
      EE_select <- EE_best <- EE_diff <- rep(NA, n_nvar)
      for(n in 1:n_nvar) {
        EE_select[n] <- out_var[[d]][[i]]$EE[n, ind_min_PE[n]]
        EE_best[n] <- out_var[[d]][[i]]$EE[n, ind_min_EE[n]]
        EE_diff <- EE_best - EE_select
      }
      a_out[d, i, , 1] <- EE_diff
      
      # ------ Rule 2: SE -----
      ind_selVAR <- out_var[[d]][[i]]$PE[, 1] > out_var[[d]][[i]]$PE[, 2] + SE_PE_VAR
      ind_modSelect <- ind_selVAR+1
      
      # Apply rule
      EE_select <- EE_best <- EE_diff <- rep(NA, n_nvar)
      for(n in 1:n_nvar) {
        EE_select[n] <- out_var[[d]][[i]]$EE[n, ind_modSelect[n]]
        EE_best[n] <- out_var[[d]][[i]]$EE[n, ind_min_EE[n]]
      }
      
      EE_diff <- EE_best - EE_select
      a_out[d, i, , 2] <- EE_diff
      
      
    } # end for: i
    
    print(d)
    
  } # end for: d
  
  a_out
}

PATH_TO_EE_COMP <- NULL

if (is.null(PATH_TO_EE_COMP)) {
  a_out <- get_ee_comp(out_var)
  # saveRDS(a_out, 'files/EE_comp.RDS') # comment out to save file
} else {
  a_out <- readRDS('files/EE_comp.RDS')
}


# compute EE_comp for all 6000 models
EE_comp_n <- matrix(0, nrow = 6000, ncol = 493)

j <- 1
for (cell in seq(n_cells)) {
  for (iter in seq(100)) {
    ee <- a_out[cell, , ,][iter, , ]
    EE_comp_n[j, ] <- ee[, 2] - ee[, 1]
    j <- j + 1
  }
}

# only get the relevant comparisons, i.e., where the two model selection strategies disagree
EE_comp_relevant <- sapply(seq(6000), function(i) {
  relevant <- which(EE_comp_n[i, ] != 0)
  EE_comp_n[i, relevant]
})


EE_comp_model_weights <- rep(model_weights, times = sapply(EE_comp_relevant, length))
EE_comp_model_weights <- EE_comp_model_weights / sum(EE_comp_model_weights)

pdf('figures/Fig4-Ngap-EEcomp-Histogram.pdf', width = 10, height = 6)
par(mfrow = c(1, 2))
plot_ngaps_hist(ngaps_models, weight = model_weights)

# plot the weighted histogram for ee_comp
wtd.hist(
  unlist(EE_comp_relevant), weight = EE_comp_model_weights, breaks = 100, main = '',
  xlab = TeX('$$Expected EE_{comp}$$'), col = 'grey76', ylab = '',
  xaxt = 'n', las = 2, ylim = c(0, .3)
)

x_labels <- seq(-.01, .05, .01)
axis(1, x_labels, las = 1)
axis(2, labels = FALSE)
title(ylab = 'Weighted Frequency', line = 3)
dev.off()


# -----------------------------------------------------------------------------
# ---------- Figure 5: Two plots about the 1SE Rule ---------------------------
# -----------------------------------------------------------------------------

#' Creates Figure 5 (a) and (b) about the 1SE Rule
plot_1SE <- function(EE_comp_n_NA) {
  # ee_comp_mean[is.na(ee_comp_mean)] <- 0 # there is no disagreement!
  # ee_comp_sd[is.na(ee_comp_sd)] <- 0 # there is no disagreement!
  ee_comp_mean <- apply(EE_comp_n_NA, 2, function(col) {
    sel <- which(!is.na(col))
    # if (length(sel) == 0) { return(NA) }
    sum(col[sel] * model_weights[sel] / sum(model_weights[sel]))
  })[seq(200)]
  
  ee_comp_sd <- apply(EE_comp_n_NA, 2, function(col) {
    sel <- which(!is.na(col))
    # if (length(sel) == 0) { return(NA) }
    get_weighted_sd(col[sel], model_weights[sel] / sum(model_weights[sel]))
  })[seq(200)]
  
  par(mfrow = c(1, 2))
   
  mul <- 100
  plot.new()
  plot.window(
    xlim = c(8, 200), ylim = c(-.005, .02) * mul, yaxs = 'i'
  )
  
  lo <- (ee_comp_mean - ee_comp_sd) * mul
  hi <- (ee_comp_mean + ee_comp_sd) * mul
  lines(ee_comp_mean * mul)
  lines(lo, col = 'skyblue')
  lines(hi, col = 'skyblue')
  
  x_labels <- c(8, 50, 100, 150, 200)
  title(xlab = 'Number of observations n', cex.lab = 1)
  title(ylab = TeX('$$EE_{comp} x 100$$'), line = 2.5, cex.lab = 1)
  
  axis(1, x_labels, cex.axis = 1.2)
  axis(2, at = c(-.005, 0, .01, .02, .03)*100, las = 2, cex.axis = 1)
  
  lines(c(0, 500), c(0, 0), lty = 2, col = 'grey')
  text(180, 1.9, '(a)', col = 'black', cex = 1.2, adj = 0)
  
  ee_prop_n <- apply(EE_comp_n_NA, 2, function(col) mean(col > 0, na.rm = TRUE))[seq(193)]
  
  
  plot.new()
  plot.window(
    xlim = c(8, 200), ylim = c(0, 1), yaxs = 'i'
  )
  
  lines(ee_prop_n)
  
  x_labels <- c(8, 50, 100, 150, 200)
  title(xlab = 'Number of observations n', cex.lab = 1)
  title(ylab = TeX('$$EE_{comp} > 0$$'), line = 2.5, cex.lab = 1)
  
  axis(1, x_labels, cex.axis = 1.2)
  axis(2, seq(0, 1, .2), las = 2, cex.axis = 1)
  
  lines(c(0, 500), c(.5, .5), lty = 2, col = 'grey')
  text(180, .97, '(b)', col = 'black', cex = 1.2, adj = 0)
}

pdf("Figures/Fig5-1SE.pdf", width = 10, height = 5)
plot_1SE(EE_comp_n_NA)
dev.off()



# -----------------------------------------------------------------------------
# ---------- Figure: Appendix -------------------------------------------------
# -----------------------------------------------------------------------------

# Import data from "SampleGrid.R"
m_cell_fill <- readRDS(file="files/cell_positions.RDS")
out_stable <- readRDS(file = "files/initial10000.RDS")

sc <- 1
pdf("Figures/Simulation3_RD_CellSampling.pdf", width = 7*sc, height = 7*sc)

# Set up Plot
plot.new()
plot.window(xlim=c(0, 9), ylim=c(0, 0.6))
axis(1, 0:9)
axis(2, seq(0, .6, length=7), las=2)
title(xlab = "Ratio: Diagonal/Off-Diagonal")
title(ylab = "Dimensionality")

# Make a Grid
sec_x <- seq(0, 9, length=18+1)
sec_y <- seq(0, .6, length=12+1)

rect(xleft = sec_x[-11], 
     ybottom = 0, 
     xright = sec_x[-1],
     ytop = .6)
rect(xleft = 0, 
     ybottom = sec_y[-11], 
     xright = 9,
     ytop = sec_y[-1])

# Plot initial data
col <- scales::alpha("black", alpha = .3)
points(out_stable[, 1], out_stable[, 2], col = col, pch=20)

# Plot Cell numbers
for(k in 1:60) text(m_cell_fill[k, 1], m_cell_fill[k, 2], k, col="red")

dev.off()